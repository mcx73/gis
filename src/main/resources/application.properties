spring.datasource.url=jdbc:postgresql://localhost:5432/gisAPK
spring.datasource.username=postgres
spring.datasource.password=Vfhfajy73
# выводит тела запросов к Ѕƒ в консоль
spring.jpa.show-sql=true
# что бы схема базы данных создавалась при запуске приложени€
spring.jpa.generate-ddl=false
# позвол€ет задать стратегию формировани€ Ѕƒ на основе наших моделей, имеет разные значени€ (none, create, update и др.).
# update в данном случае значит, что таблицы Ѕƒ и пол€ будут созданы на основе наших моделей и буду измен€тьс€ вместе с ними.
spring.jpa.hibernate.ddl-auto=update
#добавл€етс€ в качестве обходного пути дл€ ошибки "метод org.postgresql.jdbc.PgConnection.createClob () еще не реализован."
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
# спринг возьмет на себ€ всю работу по хранению сессий пользовател€ в своих базах
spring.session.jdbc.initialize-schema=always
#сажим спрингу как мы хотим назвать таблицу по хранинию наших сессий
spring.session.jdbc.table-name=SPRING_SESSION

spring.mvc.view.prefix = /WEB-INF/jsp/
spring.mvc.view.suffix = .jsp

#≈сли мы хотим контролировать максимальный размер загружаемого файла
#spring.servlet.multipart.max-file-size=128KB
#spring.servlet.multipart.max-request-size=128KB

upload.path=D\:\\uploads

#также можем контролировать, включена ли загрузка файлов, и место загрузки файлов
#внимание, что мы использовали $ {java.io.tmpdir} дл€ определени€ местоположени€ загрузки, чтобы мы могли использовать
# временное местоположение дл€ разных операционных систем
#spring.servlet.multipart.enabled=true
#spring.servlet.multipart.location=${java.io.tmpdir}

